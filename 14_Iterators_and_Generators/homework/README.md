
# Գործնական աշխատանք

## Գործնական աշխատանքի նպատակները

- Ամրապնդել «իտերատոր» և «գեներատոր» հասկացությունները, կիրառել `iter` և `next` մեթոդների օգտագործումը։
- Զարգացնել դասեր-իտերատորներ և ֆունկցիաներ-գեներատորներ ստեղծելու հմտությունները, ինչպես նաև գեներատոր արտահայտությունների կիրառումը։
- Վերամշակել տիպերի անոտացիաների օգտագործումը։

## Աշխատանքի բաղադրիչները

1. **Խնդիր 1. Թվերի քառակուսիներ**

   
     ### Ինչ է պետք անել
     Օգտագործողը ներմուծում է թիվ `N`։ Գրել ծրագիր, որը գեներացնում է թվերի քառակուսիների հաջորդականությունը 1-ից `N` (1 \*\* 2, 2 \*\* 2, 3 \*\* 2 և այլն)։ Իրականացումը գրել երեք եղանակով՝ դաս-իտերատոր, ֆունկցիա-գեներատոր և գեներատոր արտահայտություն։
   
     ### Ինչ է գնահատվում
     - Հաշվարկների արդյունքները ճիշտ են։
     - Մուտքը պարունակում է ճիշտ հրավերներ ներմուծման համար։
     - Մոդելները իրականացված են ՕՕՊ ոճով, հիմնական ֆունկցիոնալը նկարագրված է դասերի մեթոդներում և առանձին ֆունկցիաներում։
     - Դասերի ստեղծման ժամանակ պահպանվում են ՕՕՊ հիմնական սկզբունքները՝ ինկապսուլյացիա, ժառանգություն և պոլիմորֆիզմ։
     - Պրիվատ ատրիբուտների արժեքները ստանալու և տեղադրելու համար օգտագործվում են սեթերներ և գեթերներ։
     - Նոր դաս ստեղծելու համար, հիմնված արդեն գոյություն ունեցողի վրա, օգտագործվում է ժառանգություն։
     - Արդյունքի ստացման գործընթացի մասին հաղորդագրությունները իմաստալից և հասկանալի են օգտատիրոջ համար։
     - Փոփոխականները, ֆունկցիաները և դասերի մեթոդները ունեն նշանակալի անուններ (ոչ `a`, `b`, `c`, `d`)։
     - Դասերը և մեթոդները/ֆունկցիաները ունեն գրված փաստաթղթավորում։
     - Կա տիպերի անոտացիա մեթոդների/ֆունկցիաների և նրանց արգումենտների համար (բացառությամբ `args` և `kwargs`)։ Եթե ֆունկցիան/մեթոդը ոչինչ չի վերադարձնում, ապա օգտագործվում է `None`։

2. **Խնդիր 2. Ֆայլերի ուղիներ**

   
     ### Ինչ է պետք անել
     Իրականացնել `gen_files_path` ֆունկցիա, որը ռեկուրսիվ անցնում է բոլոր կատալոգներով (ներառյալ ներդրված թղթապանակներն ու ենթաթղթապանակները) նշված դիրեկտորիայի (լռությամբ՝ հիմնական սկավառակ) մեջ, գտնում է օգտագործողի նշած կատալոգը և գեներացնում է բոլոր հանդիպած ֆայլերի ուղիները։

     **Հուշում**: Ռեկուրսիվ կոդ գրելու փոխարեն, օգտագործել պատրաստի ռեկուրսիվ ֆունկցիան՝ `os.walk()` (`os` - Օպերացիոն համակարգի ինտերֆեյսեր — Python 3.11.0 փաստաթղթավորում)։
   
     ### Ինչ է գնահատվում
     - Հաշվարկների արդյունքները ճիշտ են։

     - Արդյունքի ստացման գործընթացի մասին հաղորդագրությունները իմաստալից և հասկանալի են օգտատիրոջ համար։

     - Փոփոխականները, ֆունկցիաները և դասերի մեթոդները ունեն նշանակալի անուններ (ոչ `a`, `b`, `c`, `d`)։

     - Դասերը և մեթոդները/ֆունկցիաները ունեն գրված փաստաթղթավորում։




3. **Խնդիր 3. Տողերի քանակը**

   
     ### Ինչ է պետք անել
     Իրականացնել ֆունկցիա-գեներատոր, որը վերցնում է բոլոր Python ֆայլերը դիրեկտորիայում և հաշվում է յուրաքանչյուր ֆայլի տողերի քանակը՝ բաց թողնելով դատարկ տողերն ու մեկնաբանությունների տողերը։ Արդյունքում, ֆունկցիա-գեներատորը պետք է օգտագործի `yield` յուրաքանչյուր անգամ, վերադարձնելով հերթական ֆայլի տողերի քանակը։
   *
     ### Ինչ է գնահատվում
     - Հաշվարկների արդյունքները ճիշտ են։
     - Մուտքը պարունակում է ճիշտ հրավերներ ներմուծման համար։
     - Արդյունքի ստացման գործընթացի մասին հաղորդագրությունները իմաստալից և հասկանալի են օգտատիրոջ համար։
     - Փոփոխականները, ֆունկցիաները և դասերի մեթոդները ունեն նշանակալի անուններ (ոչ `a`, `b`, `c`, `d`)։



4. **Խնդիր 4. Միակապ ցուցակ**

   
     ### Ինչ է պետք անել
     Շարունակում ենք տվյալների կառուցվածքների և ալգորիթմների թեման։ Այս անգամ պետք է իրականացնել միակապ ցուցակ։

     Միակապ ցուցակը տվյալների կառուցվածք է, որը բաղկացած է տարրերից, որոնք կոչվում են հանգույցներ։ Հանգույցներում պահվում են տվյալներ, իսկ հանգույցները միմյանց միացված են կապերով։ Կապը ցուցակի հաջորդ կամ նախորդ տարրի հղումն է։

     Միակապ ցուցակում կապը միայն հաջորդ տարրի հղումն է, այսինքն՝ հնարավոր է շարժվել միայն դեպի ցուցակի վերջ։ Հիմնվելով ընթացիկ հանգույցի վրա՝ հնարավոր չէ իմանալ նախորդ տարրի հասցեն։

     Իրականացնել այս տվյալների կառուցվածքը՝ առանց օգտագործելու Python-ի ստանդարտ կառուցվածքները (`list`, `dict`, `tuple` և այլն) և լրացուցիչ մոդուլներ։

     Իրականացման համար գրել երկու դաս՝ `Node` և `LinkedList`։ `Node` դասում պետք է լինի մեկ հանգույցի աշխատանքի տրամաբանությունը (տվյալների և հղման պահպանումը)։

     Տվյալների կառուցվածքի համար իրականացնել հետևյալ մեթոդները՝
     - `append` — տարր ավելացնել ցուցակի վերջում։
     - `get` — տարր ստանալ ըստ ինդեքսի։
     - `remove` — տարր հեռացնել ըստ ինդեքսի։
       Լրացուցիչ՝ ցուցակը դարձնել իտերացվող՝ օգտագործելով ցիկլ։
       **Օրինակ հիմնական ծրագրի**:
     ```python
     my_list = LinkedList()
     my_list.append(10)
     my_list.append(20)
     my_list.append(30)
     print('Ընթացիկ ցուցակ:', my_list)
     print('Երրորդ տարրի ստացումը:', my_list.get(2))
     print('Երկրորդ տարրի հեռացումը:')
     my_list.remove(1)
     print('Նոր ցուցակ:', my_list)
     ```
     **Արդյունքը**:
     ```
     Ընթացիկ ցուցակ: [10 20 30]
     Երրորդ տարրի ստացումը: 30
     Երկրորդ տարրի հեռացումը:
     Նոր ցուցակ: [10 30]
     ```
   
     ### Ինչ է գնահատվում
     - Հաշվարկների արդյունքները ճիշտ են։
     - Մոդելները իրականացված են ՕՕՊ ոճով, հիմնական ֆունկցիոնալը նկարագրված է դասերի մեթոդներում և առանձին ֆունկցիաներում։
     - Դասերի ստեղծման ժամանակ պահպանվում են ՕՕՊ հիմնական սկզբունքները՝ ինկապսուլյացիա, ժառանգություն և պոլիմորֆիզմ։
     - Պրիվատ ատրիբուտների արժեքները ստանալու և տեղադրելու համար օգտագործվում են սեթերներ և գեթերներ։
     - Նոր դաս ստեղծելու համար, հիմնված արդեն գոյություն ունեցողի վրա, օգտագործվում է ժառանգություն։
     - Ելքի ձևաչափը համապատասխանում է օրինակին։
     - Փոփոխականները, ֆունկցիաները և դասերի մեթոդները ունեն նշանակալի անուններ (ոչ `a`, `b`, `c`, `d`)։
     - Դասերը և մեթոդները/ֆունկցիաները ունեն գրված փաստաթղթավորում։
     - Կա տիպերի անոտացիա մեթոդների/ֆունկցիաների և նրանց արգումենտների համար (բացառությամբ `args` և `kwargs`)։ Եթե ֆունկցիան/մեթոդը ոչինչ չի վերադարձնում, ապա օգտագործվում է `None`։

5. **Խնդիր 5. Լոգերի մշակում**

   
     ### Համատեքստ
     Դուք աշխատում եք մեծ ընկերությունում, որը սպասարկում է բարդ առևտրային համակարգ։ Ամեն օր գեներացվում են բազմաթիվ լոգ-ֆայլեր, որոնք պարունակում են տեղեկատվություն առևտրային գործարքների մասին։ Ձեր խնդիրն է մշակել ծրագիր, որը ավտոմատ կերպով վերլուծում է այդ լոգ-ֆայլերը և գտնում սխալի հաղորդագրություններ պարունակող տողերը (`ERROR`)։ Սա կօգնի արագ հայտնաբերել առևտրային համակարգի խնդիրները և արդյունավետ արձագանքել դրանց։
   
     ### Ինչ է պետք անել
     Գրել ծրագիր, որը կարդում է ֆայլից տողերը և դուրս է բերում այն տողերը, որոնք պարունակում են `ERROR` բառը՝ նոր ֆայլում պահպանելու համար։
     - Օգտագործել `os` մոդուլը ֆայլերի և ուղիների հետ աշխատելու համար։
     - Հաշվի առնել, որ ֆայլը կարող է լինել շատ մեծ, ուստի այն ամբողջությամբ հիշողություն ներբեռնելը ցանկալի չէ։
     - Ստեղծել `error_log_generator` ֆունկցիա-գեներատոր, որը կստանա լոգ ֆայլի ուղին և վերադարձնի ֆայլից այն տողերը, որոնք պարունակում են `ERROR` բառը (յուրաքանչյուր դիմում գեներատորին պետք է վերադարձնի ֆայլի հերթական տողը)։
   
     ### Ինչ է գնահատվում
     - Գործնական աշխատանքը հանձնված է GitHub-ի միջոցով։

     - Բոլոր խնդիրները կատարված են համապատասխան պանակներում և ֆայլերում `main.py`։

     - Commit֊ների նկարագրությունները իմաստալից են և հասկանալի (օր.`added m15 homework`, `14.3 fix: variables naming`)։

     - Օգտագործված են անունավոր ինդեքսներ, ոչ պարզապես `i`։

     - Օգտագործված են ճիշտ թվեր, առանց օգտատիրոջ կողմից լրացուցիչ գործողությունների։

     - Ճիշտ ձևավորված է մուտքային տեղեկատվությունը՝ առանց դատարկ հրավերների։

     - Փոփոխականները և ֆունկցիաները ունեն նշանակալի անուններ։

     - Կոդավորման ստանդարտները պահպանված են (PEP 8)։

     - Ֆայլերի հետ աշխատանքը կատարվում է `with` կառավարչի միջոցով։

     - Բացառությունների մշակման համար օգտագործվում են `try-except` բլոկներ։

     - Մոդելները իրականացված են ՕՕՊ ոճով։

     - ՕՕՊ հիմնական սկզբունքները պահպանված են։

     - Եթե դասերը դուրս են բերված առանձին մոդուլում, ապա օգտագործվում են հստակ դասեր՝ ոչ թե `from module_name import *`։

     - Կա տիպերի անոտացիա մեթոդների/ֆունկցիաների և նրանց արգումենտների համար։
