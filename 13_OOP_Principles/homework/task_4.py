"""Խնդիր 5. Stack
Ինչ անել
Մենք արդեն ասել ենք, որ ծրագրավորման մեջ հաճախ անհրաժեշտ է լինում ստեղծել ձեր սեփական տվյալների կառուցվածքները՝ հիմնվելով առկաների վրա։ Այդպիսի հիմնական կառուցվածքներից մեկը stack֊ն է:

Ստեկը վերացական տվյալների տեսակ է, որը LIFO սկզբունքի համաձայն կազմակերպված տարրերի ցանկ է (վերջին մուտքը - առաջին դուրս):

Պարզ օրինակ՝ գրքերի կույտ սեղանի վրա: Միակ գիրքը, որի կազմը տեսանելի է, վերևն է։ Որպեսզի մուտք գործենք, օրինակ, երրորդ գիրքը ներքևից, մենք պետք է մեկ առ մեկ հեռացնենք վերևի բոլոր գրքերը:

Գրեք դաս, որն իրականացնում է ստեկը և դրա հնարավորությունները (տարր ավելացնելն ու հեռացնելը բավական կլինի):

Դրանից հետո գրեք ևս մեկ դաս՝ «Առաջադրանքների կառավարիչ»: Առաջադրանքների կառավարիչում կարող եք կատարել «նոր առաջադրանք» հրամանը, որին փոխանցվում են հենց առաջադրանքը (str) և դրա առաջնահերթությունը (int): Կառավարիչն ինքն է աշխատում ստեկի հիման վրա (ոչ ժառանգական): Երբ մենեջերը ցուցադրում է վահանակը, բոլոր առաջադրանքները պետք է դասակարգվեն հետևյալ առաջնահերթությամբ՝ որքան փոքր է թիվը, այնքան մեծ է առաջադրանքը:

Ահա հիմնական ծրագրի օրինակ.

manager = TaskManager()

manager.new_task(«մաքրել», 4)

manager.new_task («լվալ ամանները», 4)

manager.new_task(«հանգիստ», 1)

manager.new_task(«ուտել», 2)

manager.new_task(«անցնել աշխատանքային հանձնարարությանը», 2)

print(manager)

Արդյունք:

1 - հանգիստ

2 - ուտել; աշխատանքի թույլտվությունը հանձնել

4 - կատարել մաքրում; լվանալ սպասքը

Բացի այդ. իրականացնել նաև առաջադրանքների ջնջում և մտածել, թե ինչ անել կրկնօրինակների հետ:

Ինչ է գնահատվում
Հաշվարկի արդյունքը ճիշտ է։
Մոդելներն իրականացվում են OOP ոճով, հիմնական ֆունկցիոնալությունը նկարագրված է դասի մեթոդներով և անհատական ​​գործառույթներով:
Դասեր գրելիս պահպանվում են OOP-ի հիմնական սկզբունքները՝ ինկապսուլյացիան, ժառանգականությունը և պոլիմորֆիզմը:
Սահմանիչները և ստացողները օգտագործվում են մասնավոր ատրիբուտների արժեքներ ստանալու և սահմանելու համար:
Ժառանգությունն օգտագործվում է գոյություն ունեցող դասի հիման վրա նոր դաս ստեղծելու համար:
Ելքային ձևաչափը հետևում է օրինակին:
Փոփոխականները, ֆունկցիաները և դասերի սեփական մեթոդներն ունեն իմաստալից անուններ, այլ ոչ թե a, b, c, d:
Դասերը և մեթոդները/գործառույթները ունեն գրավոր փաստաթղթեր:
"""


class Stack:
    def __init__(self):
        self.data = []

    def add(self, elem):
        self.data.append(elem)

    def delete(self):
        del self.data[-1]

    def __str__(self):
        self.data.sort()
        res = ''
        for priority, *task in self.data:
            res += f"{priority} - {'; '.join(task)}\n"
        return res

class TaskManager:
    def __init__(self):
        self.stack = Stack()

    def new_task(self, task, priority):
        for item in self.stack.data:
            if priority in item:
                item.append(task)
                break
        else:
            self.stack.add([priority, task])

    def del_task(self):
        self.stack.delete()

manager = TaskManager()

manager.new_task('մաքրել', 4)
manager.new_task ('լվալ ամանները', 4)
manager.new_task('հանգիստ', 1)
manager.new_task('ուտել', 2)
manager.new_task('անցնել աշխատանքային հանձնարարությանը', 2)

manager.del_task()
print(manager.stack)