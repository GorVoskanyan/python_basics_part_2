
# Պատրաստի տվյալների կառուցվածքների իրականացումներ: հերթ, ստեկ, բինար ծառ, կապակցված ցուցակ

## Ինչի մասին կսովորեք

Այս մոդուլում դուք՝

- Կսովորեք նոր գրադարանների մասին, որոնք կօգնեն աշխատել ոչ ստանդարտ տվյալների կառուցվածքների հետ:
- Խորությամբ կուսումնասիրեք տվյալների կառուցվածքները (ստեկ, հերթ, կապակցված ցուցակ, բինար ծառ):
- Կսովորեք կատարել ընտրություն տվյալների կառուցվածքների բազմազանությունից:

## collections մոդուլը

Տվյալների կառուցվածքների մեծամասնությունը ունի հաստատված իրականացում, ուստի ամեն անգամ ձեռքով դրանց ստեղծման անհրաժեշտություն չկա:

Երբ խոսքը գնում է լրացուցիչ տվյալների կառուցվածքների պատրաստի իրականացման մոդուլների մասին, առաջին հերթին պետք է հիշատակել collections մոդուլը:

### collections մոդուլը

- Տեղադրում։ collections մոդուլը հանդիսանում է Python-ի ներկառուցված մոդուլ, ուստի լրացուցիչ տեղադրում չի պահանջվում:
- **Միացում**: Ներմուծեք այն օգտագործելով `import collections`:

### Ամենահայտնի և օգտակար տվյալների կառուցվածքները մոդուլում

1. **deque**

   Ներկայացնում է երկկողմանի հերթ: Թույլ է տալիս ավելացնել և ջնջել տարրերը ինչպես հերթի սկզբից, այնպես էլ վերջից:

   Օրինակ՝

   ```python
   from collections import deque
   queue = deque()
   queue.append(1) # Ավելացնել տարրը հերթի վերջում
   queue.append(2)
   queue.appendleft(3) # Ավելացնել տարրը հերթի սկզբում

   print(queue) # Արդյունք: deque([3, 1, 2])

   item = queue.popleft() # Ջնջել և ստանալ տարրը հերթի սկզբից
   print(item) # Արդյունք: 3
   ```

2. **Counter**

   Օգտագործվում է օբյեկտների հաշվարկի համար, հարմար է հաշվարկներ և տվյալների վերլուծություն կատարելու համար:

   Օրինակ՝

   ```python
   from collections import Counter

   data = [1, 2, 3, 1, 2, 1, 3, 4, 5, 4, 2, 1]
   counter = Counter(data)

   print(counter) # Արդյունք: Counter({1: 4, 2: 3, 3: 2, 4: 2, 5: 1})

   print(counter[1]) # Արդյունք: 4 (թվի 1-ի հանդիպումների քանակը)

   most_common = counter.most_common(2)
   print(most_common) # Արդյունք: [(1, 4), (2, 3)] (ամենահաճախ հանդիպող տարրերը)
   ```

3. **namedtuple**

   Թույլ է տալիս ստեղծել անվանված կորտեժներ, որոնք անփոփոխելի հավաքածուներ են՝ հասանելի ըստ անունների:

   Օրինակ՝

   ```python
   from collections import namedtuple

   Point = namedtuple('Point', ['x', 'y'])
   p = Point(2, 3)

   print(p.x) # Արդյունք: 2
   print(p.y) # Արդյունք: 3
   ```

4. **defaultdict**

   `defaultdict`-ը բառարանի ենթադաս է, որը տրամադրում է կանխադրված արժեք բացակայող բանալիների համար: Դա հարմար է, երբ անհրաժեշտ է խուսափել բանալիների առկայության ստուգումներից:

   Օրինակ՝

   ```python
   from collections import defaultdict

   # Ստեղծել defaultdict, որի կանխադրված արժեքը՝ դատարկ ցուցակ
   d = defaultdict(list)

   d['apple'].append('red') # Ավելացնել 'red' արժեքը 'apple' բանալու համար
   d['banana'].append('yellow') # Ավելացնել 'yellow' արժեքը 'banana' բանալու համար
   d['apple'].append('green') # Ավելացնել 'green' արժեքը 'apple' բանալու համար

   print(d) # Արդյունք: defaultdict(<class 'list'>, {'apple': ['red', 'green'], 'banana': ['yellow']})
   print(d['apple']) # Արդյունք: ['red', 'green']

   print(d['banana']) # Արդյունք: ['yellow']

   print(d['cherry']) # Արդյունք: [] (դատարկ ցուցակ, կանխադրված արժեք)
   print(d) # Արդյունք: defaultdict(<class 'list'>, {'apple': ['red', 'green'], 'banana': ['yellow'], 'cherry': []})
   ```

   Այս օրինակում `defaultdict(list)` ստեղծում է բառարան, որտեղ բացակայող բանալիներին ավտոմատ կերպով համապատասխանեցվում է դատարկ ցուցակ: Դա թույլ է տալիս ավելացնել արժեքներ բանալիներին առանց նախնական ստուգման՝ արդյոք դրանք գոյություն ունեն: Եթե դիմեք գոյություն չունեցող բանալիին, `defaultdict`-ը ավտոմատ կերպով կստեղծի նոր գրառում կանխադրված արժեքով:

## queue մոդուլը

Մոդուլը queue նույնպես հանդիսանում է ներկառուցված Python մոդուլ, ուստի լրացուցիչ տեղադրում չի պահանջվում:

### Queue

`Queue`-ը ներկայացնում է հոսքապաշտպան հերթի (queue) իրականացում Python-ում, որը գործում է "առաջինը ներս, առաջինը դուրս" (FIFO) սկզբունքով:

Օրինակ՝

```python
from queue import Queue

# Ստեղծել հերթի օրինակ
q = Queue()

# Ավելացնել տարրեր հերթում
q.put(1)
q.put(2)
q.put(3)

# Ստանալ և ջնջել տարր հերթից
item = q.get()
print(item) # Արդյունք: 1

# Ստուգել, արդյոք հերթը դատարկ է
is_empty = q.empty()
print(is_empty) # Արդյունք: False

# Ստանալ հերթի չափը
size = q.qsize()
print(size) # Արդյունք: 2

# Մաքրել հերթը
q.queue.clear()

# Ստուգել, արդյոք հերթը դատարկ է մաքրումից հետո
is_empty = q.empty()
print(is_empty) # Արդյունք: True
```

### LifoQueue

`LifoQueue`-ը ներկայացնում է ստեկի իրականացում, որը գործում է "վերջինը ներս, առաջինը դուրս" (LIFO) սկզբունքով:

Օրինակ՝

```python
from queue import LifoQueue

# Ստեղծել ստեկի օրինակ
stack = LifoQueue()

# Ավելացնել տարրեր ստեկում
stack.put(1)
stack.put(2)
stack.put(3)

# Ստանալ և ջնջել տարր ստեկից
item = stack.get()
print(item) # Արդյունք: 3

# Ստուգել, արդյոք ստեկը դատարկ է
is_empty = stack.empty()
print(is_empty) # Արդյունք: False

# Ստանալ ստեկի չափը
size = stack.qsize()
print(size) # Արդյունք: 2

# Մաքրել ստեկը
stack.queue.clear()

# Ստուգել, արդյոք ստեկը դատարկ է մաքրումից հետո
is_empty = stack.empty()
print(is_empty) # Արդյունք: True
```

## Կապակցված ցուցակ (Linked List)

Կապակցված ցուցակը տվյալների կառուցվածք է, որը բաղկացած է հանգույցներից, որոնցից յուրաքանչյուրը պարունակում է արժեք և հղում դեպի հաջորդ հանգույցը:

Կապակցված ցուցակների առավելությունները՝

- **Արդյունավետ տեղադրում և ջնջում**: Տեղադրումն ու ջնջումը ցուցակի մեջ կամ սկզբում ավելի արագ են, քան սովորական ցուցակում, և չեն պահանջում այլ տարրերի տեղափոխում կամ հիշողության վերակազմակերպում:
- **Պարզ իրականացում**: Կապակցված ցուցակների իրականացումը համեմատաբար պարզ է:
- **Կարելի է օգտագործել ստեկների և հերթերի իրականացման համար**: Հարմար է հատկապես այն դեպքերում, երբ անհրաժեշտ է պահպանել տվյալների ավելացման կամ հեռացման կարգը:

Կապակցված ցուցակների հիմնական թերությունները՝

- **Սահմանափակ մուտք**: Կապակցված ցուցակի տարրերի հասանելիությունը կատարվում է հաջորդական՝ առաջին հանգույցից սկսած, ինչը կարող է լինել դանդաղ՝ O(n) ժամանակատարություն:
- **Հավելյալ հիշողության օգտագործում**: Յուրաքանչյուր հանգույց պահանջում է հավելյալ հիշողություն՝ պահելու արժեքը և հաջորդ հանգույցի հղումը:

Կապակցված ցուցակի պարզ իրականացում՝

```python
class Node:
    def __init__(self, data, next=None):
        self.data = data  # Հանգույցի արժեքը
        self.next = next  # Հղում դեպի հաջորդ հանգույցը

# Ստեղծել առաջին հանգույցը
first = Node(123)
# Ստեղծել հաջորդ հանգույցը, որը կցուցակվի դեպի առաջինը
second = Node(456, first)

print(second.next.data) # Արդյունք: 123
```

Այս օրինակը պարզ իրականացումը բավական է կապակցված ցուցակի համար: Ավելի բարդ իրացումների դեպքում հաճախ ստեղծվում է նաև երկրորդ դաս՝ `LinkedList`, որը ծառայում է որպես կառավարիչ՝ հեշտացնելու հանգույցների հետ աշխատանքը:

Կապակցված ցուցակները հաճախ օգտագործվում են ստեկների և հերթերի իրականացման, պատմությունների կառավարման, և մեծ տվյալների մշակման համար:

## Բինար ծառ (Binary Tree)

Բինար ծառը տվյալների կառուցվածք է, որը բաղկացած է հանգույցներից, որոնցից յուրաքանչյուրը կարող է ունենալ առավելագույնը երկու դուստր հանգույց՝ կոչվող ձախ և աջ ենթածառեր:

Բինար ծառի պարզ իրականացում՝

```python
class Node:
    def __init__(self, key):
        self.key = key  # Հանգույցի արժեքը
        self.left = None  # Ձախ դուստր հանգույցի հղում
        self.right = None  # Աջ դուստր հանգույցի հղում

# Ստեղծել բինար ծառի արմատային հանգույցը
root = Node(10)
root.left = Node(2)  # Ավելացնել ձախ դուստր հանգույց
root.right = Node(15)  # Ավելացնել աջ դուստր հանգույց

# Վիզուալ ներկայացում բինար ծառի:
#     10
#    /  \
#   2   15
```

Այս օրինակը բինար ծառի ամենապարզ ձևն է, որտեղ յուրաքանչյուր հանգույց կարող է ունենալ առավելագույնը երկու դուստր հանգույց: Ձախ հանգույցը պարունակում է արժեք, որը փոքր է "ծնող" հանգույցի արժեքից, իսկ աջ հանգույցը՝ մեծ:

Բինար ծառերը հաճախ օգտագործվում են որոնման գործընթացը հեշտացնելու համար, ինչը հնարավորություն է տալիս ավելի արագ գտնել տարրերը:

Բինար ծառի ավելի բարդ իրականացում՝ օգտագործելով `binarytree` մոդուլը՝

```python
from binarytree import Node

# Ստեղծել բինար ծառ
root = Node(10)
root.left = Node(5)
root.right = Node(15)
root.left.left = Node(3)
root.left.right = Node(7)

# Տպել բինար ծառի կառուցվածքը
print("Բինար ծառի կառուցվածք:")
print(root)

# Ծառի շրջանցում (preorder)
def preorder(node):
    if node is not None:
        print(node.value)
        preorder(node.left)
        preorder(node.right)

print("Ծառի շրջանցում (preorder):")
preorder(root)

# Արժեքի որոնում ծառում
def search(node, value):
    if node is None or node.value == value:
        return node
    if value < node.value:
        return search(node.left, value)
    return search(node.right, value)

print("Արժեքի որոնում ծառում:")
result = search(root, 7)
if result is not None:
    print("Արժեքը գտնված է!")
else:
    print("Արժեքը չի գտնվել!")
```

Բինար ծառերը լայնորեն օգտագործվում են տարբեր կիրառություններում, օրինակ՝ տվյալների բազաներում, տվյալների սեղմման ալգորիթմներում և տվյալների կառավարման մեջ:

